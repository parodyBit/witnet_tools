import random
import secrets
from math import gcd
from typing import Tuple

import sys

sys.setrecursionlimit(1_000_000)


def miller_rabin(n, runs=40):
    # Implementation uses the Miller-Rabin Primality Test The optimal number of rounds for this test is 40 See
    # http://stackoverflow.com/questions/6325576/how-many-iterations-of-rabin-miller-should-i-use-for-cryptographic
    # -safe-primes for justification

    if n < 6:  # assuming n >= 0 in all cases... shortcut small cases here
        return [False, False, True, True, False, True][n]

    # If number is even, it's a composite number
    elif n & 1 == 0:  # should be faster than n % 2
        return False
    else:
        r, s = 0, n - 1
        while s % 2 == 0:
            r += 1
            s //= 2
        for _ in range(runs):
            a = random.randrange(3, n - 1, 2)
            x = pow(a, s, n)
            if x == 1 or x == n - 1:
                continue
            for _ in range(r - 1):
                x = pow(x, 2, n)
                if x == n - 1:
                    break
            else:
                return False
        return True


def random_prime(bits):
    while True:
        n = secrets.randbits(bits)
        if miller_rabin(n):
            return n


def random_coprime(n):
    assert n > 1
    while True:
        e = random.randrange(1, n)
        if gcd(n, e) == 1:
            return e


def xgcd(b: int, n: int) -> Tuple[int, int, int]:
    """Takes positive integers a, b as input, and return a triple (g, x, y), such that ax + by = g = gcd(a, b)"""
    x0, x1, y0, y1 = 1, 0, 0, 1
    while n != 0:
        q, b, n = b // n, n, b % n
        x0, x1 = x1, x0 - q * x1
        y0, y1 = y1, y0 - q * y1
    return b, x0, y0


def egcd(b: int, n: int) -> Tuple[int, int, int]:
    """Takes positive integers a, b as input, and return a triple (g, x, y), such that ax + by = g = gcd(a, b)"""
    if b == 0:
        return n, 0, 1
    else:
        n_div_b, n_mod_b = divmod(n, b)
        g, x, y = egcd(n_mod_b, b)
        return g, y - n_div_b * x, x


def mulinv(b, n, algo=xgcd):
    """An application of extended GCD algorithm to finding modular inverses"""
    g, x, _ = algo(b, n)
    assert g == 1, 'Numbers must be coprimes'
    return x % n


def legendre(a, p):
    """https://en.wikipedia.org/wiki/Legendre_symbol"""
    assert miller_rabin(p), f"{p} is not a prime"
    mod = pow(a, (p - 1) // 2, p)
    return -1 if mod == p - 1 else mod


def modsqrt(a, p):
    """
        https://eli.thegreenplace.net/2009/03/07/computing-modular-square-roots-in-python
        Find a quadratic residue (mod p) of 'a'. p must be an odd prime.
        Solve the congruence of the form:
            x^2 = a (mod p)
        And returns x. Note that p - x is also a root.
        0 is returned if no square root exists for these a and p.
        The Tonelli-Shanks algorithm is used (except for some simple cases in which the solution is known from an
        identity). This algorithm runs in polynomial time (unless the generalized Riemann hypothesis is false).
    """
    # Simple cases
    #
    if legendre(a, p) != 1:
        return 0
    elif a == 0:
        return 0
    elif p == 2:
        return p
    elif p % 4 == 3:
        return pow(a, (p + 1) // 4, p)

    # Partition p-1 to s * 2^e for an odd s (i.e.
    # reduce all the powers of 2 from p-1)
    #
    s = p - 1
    e = 0
    while s % 2 == 0:
        s //= 2
        e += 1

    # Find some 'n' with a legendre symbol n|p = -1.
    # Shouldn't take long.
    #
    n = 2
    while legendre(n, p) != -1:
        n += 1

    # Here be dragons!
    # Read the paper "Square roots from 1; 24, 51,
    # 10 to Dan Shanks" by Ezra Brown for more
    # information
    #

    # x is a guess of the square root that gets better
    # with each iteration.
    # b is the "fudge factor" - by how much we're off
    # with the guess. The invariant x^2 = ab (mod p)
    # is maintained throughout the loop.
    # g is used for successive powers of n to update
    # both a and b
    # r is the exponent - decreases with each update
    #
    x = pow(a, (s + 1) // 2, p)
    b = pow(a, s, p)
    g = pow(n, s, p)
    r = e

    while True:
        t = b
        m = 0
        for m in range(r):
            if t == 1:
                break
            t = pow(t, 2, p)

        if m == 0:
            return x

        gs = pow(g, 2 ** (r - m - 1), p)
        g = (gs * gs) % p
        x = (x * gs) % p
        b = (b * g) % p
        r = m
